### BSS segment 
fixed-size segment for **uninitialized** variables 

### Data Segment 
fixed-size segment for **intialized** variables 

### Stack segment 
starts at high memory and grows toward low memory 

### Stack setup when a function(A) calls another function(B)
arguments => return pointer => saved frame pointer SFP(ebp of function A) => local variables of func B 

<p>ebp + 8 (first arguments)  + means arguments<br>
ebp - 4 (frist local variable)  - means local variables</p>

### Calling Conventions 
**cdecl** - arguments right to left & ***caller tears down the stack***

**stdcall** - arguments right to left & ***called func(callee) tears down the stack***

### Linkers vs loaders
<p>Linkers responsible for symbol resolution(resolving the function's address during runtime)<br>
Relocation - RVA + load address of program<br>
e.g. RVA of func math_calc = 0x500<br>
load addr of program = 0x800000<br>
Then true location of func = 0x800500</p>

### PLT & GOT 
**Procedure Linkage Table**
<p>responsible for calling dynamic linker to resolve the address of requested functions<br> 
read-only table</p>

**Global Offset Table**
<p>writable memory segment to store pointers<br>
updated by dynamic linker during symbol resolution </p>

**High level overview** 
<p>1.printf() absolute address ???<br> 
2.the calling program push address of GOT into a register <br>
3.From 1, request goes to PLT. First time go 4, or not go 5 <br>
4.first time, GOT sends control back to PLT.PLT call dynamic linker which resolve the symbol 
and the absolute address of func is placed into GOT entry.(lazy linking)<br> 
5.not first time, done. </p>












